'use strict';

let mongoose = require('mongoose'),
    crypto = require('crypto');

let config = require('../config/app'),
    utilCtrl = require('../controllers/util.controller');

let userSchema = new mongoose.Schema({
    name: {
        type: String,
        required: [true, 'Name is required.'],
        default: config.user.defaultName
    },

    nameNormalize: {
        type: String,
        default: this.name
    },

    avatar: {
        type: String,
        default: config.user.defaultAvatarURL
    },

    gender: {
        type: String,
        enum: ['Nam', 'Nữ', 'Khác'],
        default: config.user.gender.other
    },

    email: {
        type: String,
        lowercase: true,
        match: [/.+\@.+\..+/, 'Invalid e-mail.']
    },

    phoneNumber: {
        type: String,
        index: true,
        required: [true, 'Phone number is required.'],
        unique: [true, 'This phone number is registered.']
    },

    password: {
        type: String,
        required: [true, 'Password is required.'],
        validate: [isValidPassword, 'Password should be longer 6 characters.']
    },

    salt: String,

    address: {
        type: String,
        trim: true
    },

    website: {
        type: String,
        trim: true,
        default: config.user.defaultWebsite
    },

    fanpage: {
        type: String,
        trim: true,
        default: config.user.defaultFanpage
    },

    rating: {
        type: Number,
        default: 0.0
    },

    // Role type: NORMAL - Normal user, PROVIDER - Provider user
    role: {
        type: String,
        enum: ['NORMAL', 'PROVIDER'],
        required: [true, 'Role is required.'],
        default: config.user.role.normal
    },

    subscribingTopic: [
        {
            _publisherId: {
                type: mongoose.Schema.ObjectId,
                required: [true, 'Publisher id is required.']
            },

            // Subscribed Type: PROVIDER - subscribing a provider
            // CATEGORY - subscribing a category
            subscribeType: {
                type: String,
                enum: ['PROVIDER', 'CATEGORY'],
                default: config.user.role.provider
            }
        }
    ],

    registeredPromotion: [
        {
            type: mongoose.Schema.ObjectId,
            ref: 'Promotion',
            unique: true
        }
    ],

    pinnedPromotion: [
        {
            type: mongoose.Schema.ObjectId,
            ref: 'Promotion',
            unique: true
        }
    ],

    followingCount: {
        type: Number,
        default: 0
    },

    followedCount: {
        type: Number,
        default: 0
    },

    promotionCount: {
        type: Number,
        default: 0
    },

    accessToken: String,

    provider: {
        type: String,
        enum: ['vcoupon', 'facebook', 'google'],
        required: [true, 'Provider is required.']
    },

    providerId: String
});

// Hash user's password before saving user
userSchema.pre('save', function (next) {
    this.nameNormalize = utilCtrl.normalizeString(this.name);
    if (this.phoneNumber) {
        let User = mongoose.model('User');

        User.findOne({phoneNumber: this.phoneNumber}, (err, user) => {
            if (!user || err) {
                if (this.password) {
                    // Creates an autogenerated pseudo-random hashing salt
                    this.salt = new Buffer(crypto.randomBytes(16).toString('base64'), 'base64');
                    // Hash password
                    this.password = this.hashPassword(this.password);
                }
            }

            next();
        })
    }
});

// Hash password
userSchema.methods.hashPassword = function (password) {
    return crypto.pbkdf2Sync(password, this.salt, 10000, 64).toString('base64');
};

// Authenticate user
userSchema.methods.authenticate = function (password) {
    return this.password === this.hashPassword(password);
};

// Transform user to JSON
userSchema.methods.toJSON = function () {
    let user = this.toObject();
    delete user.password;
    delete user.salt;
    delete user.pinnedPromotion;
    delete user.registeredPromotion;
    delete user.subscribingTopic;
    delete user.nameNormalize;
    return user;
};

// Transform user to JSON for public profile
userSchema.methods.toJSONPublicProfile = function () {
    let user = this.toJSON();
    delete  user.accessToken;
    return user;
};

function isValidPassword(password) {
    return password && password.length >= 6;
}

mongoose.model('User', userSchema);